<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>Polyline on the Map</title>
    <link rel="stylesheet" type="text/css" href="https://js.api.here.com/v3/3.1/mapsjs-ui.css" />
    <style type="text/css">
        #map {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: grey;
        }

        #panel {
            width: 100%;
            height: 250px;
        }

        #info-box {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1000;
            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.3);
            user-select: none;
        }
    </style>
    <script type="text/javascript" src='../test-credentials.js'></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.1/mapsjs-core.js"></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.1/mapsjs-service.js"></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.1/mapsjs-ui.js"></script>
    <script type="text/javascript" src="https://js.api.here.com/v3/3.1/mapsjs-mapevents.js"></script>
    <script type="text/javascript">window.ENV_VARIABLE = 'https://developer.here.com'</script>
    <script src='https://developer.here.com/javascript/src/iframeheight.js'></script>
</head>

<body id="markers-on-the-map">
    <div id="info-box">Loading...</div>
    <div id="map"></div>
    <script type="text/javascript">

        const platform = new H.service.Platform({
            'apikey': '<<hereAPIkey>>',
            'units': '<<units>>'
        });

        // Obtain the default map types from the platform object:
        const defaultLayers = platform.createDefaultLayers();

        // Instantiate (and display) a map:
        var map = new H.Map(
            document.getElementById("map"),
            defaultLayers.vector.normal.truck, {
            zoom: <<centerZoom>>,
            center: {
                lat: <<centerLat>>,
                lng: <<centerLng>>
            },
            engineType: H.Map.EngineType['2D']
        });

        // MapEvents enables the event system
        // Behavior implements default interactions for pan/zoom (also on mobile touch environments)
        const behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));

        // Disable zoom on double-tap to allow removing waypoints on double-tap
        behavior.disable(H.mapevents.Behavior.Feature.DBL_TAP_ZOOM);

        window.addEventListener('resize', () => map.getViewPort().resize());

        // Create the default UI:
        var ui = H.ui.UI.createDefault(map, defaultLayers);

        // ROUTING LOGIC STARTS HERE

        // This variable holds the instance of the route polyline
        let routePolyline;

        /**
         * Handler for the H.service.RoutingService8#calculateRoute call
         *
         * @param {object} response The response object returned by calculateRoute method
         */
        function routeResponseHandler(response) {
            const sections = response.routes[0].sections;

            // Extract the summary information from the first section
            const summary = sections[0].summary;

            // Format the distance and travel time
            // const distance = (summary.length / 1000).toFixed(2) + ' km'; // Convert meters to kilometers
            // const travelTime = new Date(summary.travelTime * 1000).toISOString().substr(11, 8); // Convert seconds to HH:MM:SS

            updateInfoBox(`Travel Time: ${Math.round(summary.duration / 60)} mins\nDistance: ${(summary.length / 1000  * 0.621371).toFixed(1)} mi`);

            const lineStrings = [];
            sections.forEach((section) => {
                // convert Flexible Polyline encoded string to geometry
                lineStrings.push(H.geo.LineString.fromFlexiblePolyline(section.polyline));
            });
            const multiLineString = new H.geo.MultiLineString(lineStrings);
            const bounds = multiLineString.getBoundingBox();

            // Create the polyline for the route
            if (routePolyline) {
                // If the routePolyline we just set has the new geometry
                routePolyline.setGeometry(multiLineString);
            } else {
                // If routePolyline is not yet defined, instantiate a new H.map.Polyline
                routePolyline = new H.map.Polyline(multiLineString, {
                    style: {
                        strokeColor: 'rgb(0, 130, 130)',
                        lineWidth: 5
                    }
                });
            }

            // Add the polyline to the map
            map.addObject(routePolyline);
            FileMaker.PerformScript("RTE_GetRouteInstructionsWithWaypoint", JSON.stringify(response));
        }

        /**
         * Returns an instance of H.map.Icon to style the markers
         * @param {number|string} id An identifier that will be displayed as marker label
         *
         * @return {H.map.Icon}
         */
        function getMarkerIcon(id) {
            if (id == 'P') {
                return new H.map.Icon("<<urlIcon03>>", { size: { w: 40, h: 40 } });
            } else if (id == 'J') {
                return new H.map.Icon("<<urlIcon04>>", { size: { w: 40, h: 40 } });
            } else {
                const svgCircle = `<svg width="30" height="30" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="marker">
    <circle cx="15" cy="15" r="10" fill="#0099D8" stroke="#0099D8" stroke-width="4" />
    <text x="50%" y="50%" text-anchor="middle" fill="#FFFFFF" font-family="Arial, sans-serif" font-size="12px" dy=".3em">${id}</text>
  </g></svg>`;
                return new H.map.Icon(svgCircle, {
                    anchor: {
                        x: 10,
                        y: 10
                    }
                });
            }
        }

        /**
         * Create an instance of H.map.Marker and add it to the map
         *
         * @param {object} position  An object with 'lat' and 'lng' properties defining the position of the marker
         * @param {string|number} id An identifier that will be displayed as marker label
         * @return {H.map.Marker} The instance of the marker that was created
         */
        function addMarker(position, id) {
            const marker = new H.map.Marker(position, {
                data: {
                    id
                },
                icon: getMarkerIcon(id),
                // Enable smooth dragging
                volatility: true
            });

            // Enable draggable markers
            marker.draggable = true;

            map.addObject(marker);

            if (id === 'P') {
                    fetch(`https://revgeocode.search.hereapi.com/v1/revgeocode?at=${position.lat},${position.lng}&lang=en-US&apikey=<<hereAPIkey>>`)
                        .then(response => response.json())
                        .then(data => {
                            FileMaker.PerformScript("js_set_route_start_end", 1 + "\n" + data.items[0].address.label + '\n' + JSON.stringify(position));
                        })
                        .catch(err => {
                            console.error(err);
                         });
                } else if (id === 'J') {
                    fetch(`https://revgeocode.search.hereapi.com/v1/revgeocode?at=${position.lat},${position.lng}&lang=en-US&apikey=<<hereAPIkey>>`)
                        .then(response => response.json())
                        .then(data => {
                            FileMaker.PerformScript("js_set_route_start_end", 2 + "\n" + data.items[0].address.label + '\n' + JSON.stringify(position));
                        })
                        .catch(err => {
                            console.error(err);
                         });
                }

            return marker;
        }

        /**
         * This method calls the routing service to retrieve the route line geometry
         */
        function updateRoute() {
            routingParams.via = new H.service.Url.MultiValueQueryParameter(
                waypoints.map(wp => `${wp.getGeometry().lat},${wp.getGeometry().lng}!passThrough=true`));

            // Call the routing service with the defined parameters
            router.calculateRoute(routingParams, routeResponseHandler, console.error);
        }

        function updateInfoBox(content) {
            document.getElementById('info-box').innerText = content;
        }

        // ADD MARKERS FOR ORIGIN/DESTINATION
        const origin = {
            lat: <<StartLat>>,
            lng: <<StartLng>>
        };
        const destination = {
            lat: <<EndLat>>,
            lng: <<EndLng>>
        };

        const originMarker = addMarker(origin, 'P');
        const destinationMarker = addMarker(destination, 'J');

        // CALCULATE THE ROUTE BETWEEN THE TWO WAYPOINTS
        // This array holds instances of H.map.Marker representing the route waypoints
        const waypoints = []
        
        // Define the routing service parameters
        const routingParams = {
            'origin': `${origin.lat},${origin.lng}`,
            'destination': `${destination.lat},${destination.lng}`,
            // defines multiple waypoints
            'via': new H.service.Url.MultiValueQueryParameter(waypoints),
            'transportMode': '<<transportMode>>',
            'routingMode': '<<routingMode>>',
            'units': '<<units>>',
            'spans': 'truckAttributes',
            'vehicle[grossWeight]': '<<grossWeight>>',
            'vehicle[weightPerAxle]': '<<weightPerAxle>>',
            'vehicle[height]': '<<height>>',
            'vehicle[width]': '<<width>>',
            'vehicle[length]': '<<length>>',
            'vehicle[axleCount]': '<<axleCount>>',
            'vehicle[type]': '<<truckType>>',
            'vehicle[trailerCount]': '<<trailerCount>>',
            'return': 'polyline,actions,instructions,summary'
        };

        // Get an instance of the H.service.RoutingService8 service
        const router = platform.getRoutingService(null, 8);

        // Call the routing service with the defined parameters and display the route
        updateRoute();

        /**
         * Listen to the dragstart and store relevant position information of the marker
         */
        map.addEventListener('dragstart', function (ev) {
            const target = ev.target;
            const pointer = ev.currentPointer;
            if (target instanceof H.map.Marker) {
                // Disable the default draggability of the underlying map
                behavior.disable(H.mapevents.Behavior.Feature.PANNING);

                var targetPosition = map.geoToScreen(target.getGeometry());
                // Calculate the offset between mouse and target's position
                // when starting to drag a marker object
                target['offset'] = new H.math.Point(
                    pointer.viewportX - targetPosition.x, pointer.viewportY - targetPosition.y);
            }
        }, false);

        /**
         * Listen to the dragend and update the route
         */
        map.addEventListener('dragend', function (ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker) {
                // re-enable the default draggability of the underlying map
                // when dragging has completed
                behavior.enable(H.mapevents.Behavior.Feature.PANNING);
                const coords = target.getGeometry();
                const markerId = target.getData().id;

                // Update the routing params `origin` and `destination` properties
                // in case we dragging either the origin or the destination marker
                if (markerId === 'P') {
                    routingParams.origin = `${coords.lat},${coords.lng}`;
                    fetch(`https://revgeocode.search.hereapi.com/v1/revgeocode?at=${coords.lat},${coords.lng}&lang=en-US&apikey=<<hereAPIkey>>`)
                        .then(response => response.json())
                        .then(data => {
                            FileMaker.PerformScript("js_set_route_start_end", 1 + "\n" + data.items[0].address.label + '\n' + routingParams.origin);
                        })
                        .catch(err => {
                            console.error(err);
                         });
                } else if (markerId === 'J') {
                    routingParams.destination = `${coords.lat},${coords.lng}`;
                    fetch(`https://revgeocode.search.hereapi.com/v1/revgeocode?at=${coords.lat},${coords.lng}&lang=en-US&apikey=<<hereAPIkey>>`)
                        .then(response => response.json())
                        .then(data => {
                            FileMaker.PerformScript("js_set_route_start_end", 2 + "\n" + data.items[0].address.label + '\n' + routingParams.destination);
                        })
                        .catch(err => {
                            console.error(err);
                         });
                }

                updateRoute();
            }
        }, false);

        /**
         * Listen to the drag event and move the position of the marker as necessary
         */
        map.addEventListener('drag', function (ev) {
            const target = ev.target;
            const pointer = ev.currentPointer;
            if (target instanceof H.map.Marker) {
                target.setGeometry(
                    map.screenToGeo(pointer.viewportX - target['offset'].x, pointer.viewportY - target['offset'].y)
                );
            }
        }, false);

        /**
         * Listen to the tap event to add a new waypoint
         */
        map.addEventListener('tap', function (ev) {
            const target = ev.target;
            const pointer = ev.currentPointer;
            const coords = map.screenToGeo(pointer.viewportX, pointer.viewportY);

            if (!(target instanceof H.map.Marker)) {
                const marker = addMarker(coords, waypoints.length + 1);
                waypoints.push(marker);
                updateRoute();
            }
        });

        /**
         * Listen to the dbltap event to remove a waypoint
         */
        map.addEventListener('dbltap', function (ev) {
            const target = ev.target;

            if (target instanceof H.map.Marker) {
                // Prevent origin or destination markers from being removed
                if (['P', 'J'].indexOf(target.getData().id) !== -1) {
                    return;
                }

                const markerIdx = waypoints.indexOf(target);
                if (markerIdx !== -1) {
                    // Remove the marker from the array of way points
                    waypoints.splice(markerIdx, 1)
                    // Iterate over the remaining waypoints and update their data
                    waypoints.forEach((marker, idx) => {
                        const id = idx + 1;
                        // Update marker's id
                        marker.setData({
                            id
                        });
                        // Update marker's icon to show its new id
                        marker.setIcon(getMarkerIcon(id))
                    });
                }

                // Remove the marker from the map
                map.removeObject(target);

                updateRoute();
            }
        });

    </script>
</body>

</html>